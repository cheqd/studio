import Long from 'long'
import { Int53 } from '@cosmjs/math'
import { makeSignBytes } from '@cosmjs/proto-signing'
import { Secp256k1, Secp256k1Signature, sha256 } from '@cosmjs/crypto'
import { LumRegistry } from './registry'
import { AuthInfo } from './tx'
import { publicKeyToProto } from './keys'
import { Doc, SignMode, SignDoc, DocSigner, Fee } from '../types'

/**
 * Generate transaction auth info payload
 *
 * @param docSigners Document signers
 * @param fee requested fee
 * @param signMode signing mode
 */
export const generateAuthInfoBytes = (docSigners: DocSigner[], fee: Fee, signMode: SignMode): Uint8Array => {
    const authInfo = {
        signerInfos: docSigners.map((signer: DocSigner) => ({
            publicKey: publicKeyToProto(signer.publicKey),
            modeInfo: {
                single: { mode: signMode },
            },
            sequence: Long.fromNumber(signer.sequence),
        })),
        fee: {
            amount: [...fee.amount],
            gasLimit: Long.fromNumber(Int53.fromString(fee.gas).toNumber()),
        },
    };
    return AuthInfo.encode(AuthInfo.fromPartial(authInfo)).finish();
};
/**
 * Generate transaction doc to be signed
 *
 * @param doc document to create the sign version
 * @param signerIdx index of the signer in the signers field used to specify the accountNumber for signature purpose
 * @param signMode signing mode for the transaction
 */
export const generateSignDoc = (doc: Doc, signerIdx: number, signMode: SignMode): SignDoc => {
    if (signerIdx < 0 || signerIdx > doc.signers.length) {
        throw new Error('Invalid doc signer index');
    }
    const txBody = {
        messages: doc.messages,
        memo: doc.memo,
    };
    const bodyBytes = LumRegistry.encode({
        typeUrl: '/cosmos.tx.v1beta1.TxBody',
        value: txBody,
    });

    return {
        bodyBytes,
        authInfoBytes: generateAuthInfoBytes(doc.signers, doc.fee, signMode),
        chainId: doc.chainId,
        accountNumber: Long.fromNumber(doc.signers[signerIdx].accountNumber),
    };
};

/**
 * Generate transaction sign doc bytes used to sign the transaction
 *
 * @param signDoc sign doc (as generated by the generateSignDoc function)
 */
export const generateSignDocBytes = (signDoc: SignDoc): Uint8Array => {
    return makeSignBytes(signDoc);
};

/**
 * Verify that a signature is valid
 *
 * @param signature signature (as generated by the generateSignature function)
 * @param signedBytes signed bytes (as generated by the generateSignDocBytes function or by the signMessage function)
 * @param publicKey public key of the signing key pair (secp256k1)
 */
export const verifySignature = async (signature: Uint8Array, signedBytes: Uint8Array, publicKey: Uint8Array): Promise<boolean> => {
    const valid = await Secp256k1.verifySignature(Secp256k1Signature.fromFixedLength(signature), sha256(signedBytes), publicKey);
    return valid;
};